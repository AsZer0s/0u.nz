<!doctype html><html><head><meta charset="utf-8"><title>JavaScript中forEach方法的async/await异步问题</title><style>:root{--bg:#111315;--fg:#d6d6d6;--muted:#8b8b8b;--link:#8fa3ad;--link-hover:#c0d2db;--border:#2a2d30;--code-bg:#1a1d1f;--code-border:#2d3135}body{max-width:640px;margin:48px auto;padding:0 16px;background:var(--bg);color:var(--fg);font-family:'Noto Sans SC',system-ui,-apple-system,BlinkMacSystemFont;line-height:1.7}h1{font-size:1.2rem;font-weight:500;margin-bottom:12px}h2{font-size:1.1rem;font-weight:500;margin:2rem 0 1rem;color:var(--fg)}h3{font-size:1rem;font-weight:500;margin:1.5rem 0 0.75rem}.site-header{display:flex;align-items:center;gap:12px;margin-bottom:8px}.site-logo{height:10px;width:auto;display:block}nav{margin-bottom:32px;font-size:0.9rem}nav a{color:var(--muted);text-decoration:none;margin-right:12px}nav a:hover{color:var(--fg)}ul{list-style:none;padding:0;margin:0}li{margin:0.8rem 0}li a{color:var(--link);font-size:0.95rem;text-decoration:none}li a:hover{color:var(--link-hover)}.post-date{color:var(--muted);font-size:0.9rem}p{margin:1em 0}code{background:var(--code-bg);border:1px solid var(--code-border);border-radius:4px;padding:2px 6px;font-family:'Consolas','Monaco','Courier New',monospace;font-size:0.9em;color:#e6e6e6}pre{background:var(--code-bg);border:1px solid var(--code-border);border-radius:6px;padding:16px;overflow-x:auto;margin:1.5em 0}pre::-webkit-scrollbar{height:6px}pre::-webkit-scrollbar-track{background:var(--code-bg)}pre::-webkit-scrollbar-thumb{background:var(--code-border);border-radius:3px}pre::-webkit-scrollbar-thumb:hover{background:var(--muted)}pre code{background:none;border:none;padding:0;font-size:0.875em;line-height:1.6}blockquote{border-left:3px solid var(--border);padding-left:1em;margin:1.5em 0;color:var(--muted);font-style:italic}a{color:var(--link);text-decoration:none}a:hover{color:var(--link-hover)}img{max-width:100%;height:auto;border-radius:4px;margin:1.5em 0}hr{border:none;border-top:1px solid var(--border);margin:2rem 0}table{width:100%;border-collapse:collapse;margin:1.5em 0}th,td{border:1px solid var(--border);padding:8px 12px;text-align:left}th{background:var(--code-bg);font-weight:500}article ul,article ol{list-style:initial;padding-left:2em;margin:1em 0}article li{margin:0.5em 0}footer{margin-top:3rem;padding-top:2rem;border-top:1px solid var(--border);text-align:center}.footer-logo{height:32px;width:auto;display:inline-block;opacity:0.6;transition:opacity 0.3s}.footer-logo:hover{opacity:1}</style><style> .post-meta{display:flex;align-items:center;gap:10px;font-size:13px;color:var(--muted);margin-bottom:24px;flex-wrap:wrap;}.post-tags{display:flex;gap:8px;flex-wrap:wrap;}.tag{font-size:12px;color:var(--muted);text-decoration:none;}.tag::before{content:"#";opacity:.4;}.tag:hover{color:var(--fg);} </style><script> MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']], processEscapes: true, processEnvironments: true }, options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'] } }; </script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet"></head><body><p><a href="/">← index</a></p><h1>JavaScript中forEach方法的async/await异步问题</h1><div class="post-meta"><span>2025-03-11</span><div class="post-tags"><a class="tag" href="/tags/开发">开发</a><a class="tag" href="/tags/前端">前端</a><a class="tag" href="/tags/JavaScript">JavaScript</a></div></div><article><p>最近在用Node JS写个小项目的时候发现了一个之前没有注意过的问题<br> 数组使用forEach方法进行异步操作时执行顺序可能会出现问题<br> 这篇文章就来简单谈一谈产生这个问题具体原因以及解决方法</p><h2>问题描述</h2><p>当时遇到的问题与SQL写入操作有关，简化一下相当于：</p><pre><code class="language-javascript">var numList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; numList.forEach(async (e)=&gt;{ await new Promise((res, rej)=&gt;{ //模拟一个耗时不确定的异步过程 setTimeout(()=&gt;{ console.log(e) res(e); }, Math.random()*1000); }); }); </code></pre><p>本来期望的是使用await来阻塞异步函数，使其按循环顺序得到结果<br> 但实际得到的却是一个随机的数列<br> 下面来分析一下原因</p><h2>for循环中的情况</h2><p>将上面的代码用for循环改写得到</p><pre><code class="language-javascript">var numList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; (async function(){ for (let index = 0; index &lt; numList.length; index++) { const element = numList[index]; await new Promise((res, rej)=&gt;{ //模拟一个耗时不确定的异步过程 setTimeout(()=&gt;{ console.log(element) res(element); }, Math.random()*1000); }); } })(); </code></pre><p>运行得到的结果是按顺序排列的。用同样的方式分别用for…of循环以及map、filter、reduce等方法将代码进行改写，测试后得出结论：<br><strong>async/await在for/for…of循环中可以正常按期望运行，在使用回调函数的数组方法(forEach、map、filter、reduce)时会出现问题</strong></p><h2>原因探究</h2><p>其实说到这里解决方法已经很明显了，<strong>将数组方法(forEach)替换为循环(for/for…of)即可解决</strong>，那么我们继续来探究一下具体的原因。<br> 众所周知，await/async本质上就是Promise的一个语法糖，所以问题应该是出现在forEach方法上。<br> 通过查阅MDN文档，我找到了forEach方法的Pollyfill如下(也看到了对这个问题的特别提醒。。。早点看就不会出这个问题了)</p><pre><code class="language-javascript">// Production steps of ECMA-262, Edition 5, 15.4.4.18 // Reference: http://es5.github.io/#x15.4.4.18 if (!Array.prototype.forEach) { Array.prototype.forEach = function(callback, thisArg) { var T, k; if (this == null) { throw new TypeError(' this is null or not defined'); } // 1. Let O be the result of calling toObject() passing the // |this| value as the argument. var O = Object(this); // 2. Let lenValue be the result of calling the Get() internal // method of O with the argument &quot;length&quot;. // 3. Let len be toUint32(lenValue). var len = O.length &gt;&gt;&gt; 0; // 4. If isCallable(callback) is false, throw a TypeError exception. // See: http://es5.github.com/#x9.11 if (typeof callback !== &quot;function&quot;) { throw new TypeError(callback + ' is not a function'); } // 5. If thisArg was supplied, let T be thisArg; else let // T be undefined. if (arguments.length &gt; 1) { T = thisArg; } // 6. Let k be 0 k = 0; // 7. Repeat, while k &lt; len while (k &lt; len) { var kValue; // a. Let Pk be ToString(k). // This is implicit for LHS operands of the in operator // b. Let kPresent be the result of calling the HasProperty // internal method of O with argument Pk. // This step can be combined with c // c. If kPresent is true, then if (k in O) { // i. Let kValue be the result of calling the Get internal // method of O with argument Pk. kValue = O[k]; // ii. Call the Call internal method of callback with T as // the this value and argument list containing kValue, k, and O. callback.call(T, kValue, k, O); } // d. Increase k by 1. k++; } // 8. return undefined }; } </code></pre><p>可以看到，第56行在while循环内直接调用了我们的回调函数<br> 由于await必须位于异步函数之中，要与async成对使用，导致我们传入的回调函数其实是一个异步函数(或者说是Promise)<br> 由于没有await的阻塞，循环内部按异步执行，导致了顺序与期望的不同<br><strong>而解决方法就是将数组方法(forEach)替换为循环(for/for…of)</strong></p><h2>参考资料：</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="noopener noreferrer">MDN Web Doc: Array.prototype.forEach()</a></p></article><hr><p><a href="/">← index</a></p><footer><img src="/0unz.png" alt="0u logo" class="footer-logo"></footer></body></html>