<!doctype html><html><head><meta charset="utf-8"><title>search · 0u</title><style>:root{--bg:#111315;--fg:#d6d6d6;--muted:#8b8b8b;--link:#8fa3ad;--link-hover:#c0d2db;--border:#2a2d30;--code-bg:#1a1d1f;--code-border:#2d3135}body{max-width:640px;margin:48px auto;padding:0 16px;background:var(--bg);color:var(--fg);font-family:'Noto Sans SC',system-ui,-apple-system,BlinkMacSystemFont;line-height:1.7}h1{font-size:1.2rem;font-weight:500;margin-bottom:12px}h2{font-size:1.1rem;font-weight:500;margin:2rem 0 1rem;color:var(--fg)}h3{font-size:1rem;font-weight:500;margin:1.5rem 0 0.75rem}.site-header{display:flex;align-items:center;gap:12px;margin-bottom:8px}.site-logo{height:10px;width:auto;display:block}nav{margin-bottom:32px;font-size:0.9rem}nav a{color:var(--muted);text-decoration:none;margin-right:12px}nav a:hover{color:var(--fg)}ul{list-style:none;padding:0;margin:0}li{margin:0.8rem 0}li a{color:var(--link);font-size:0.95rem;text-decoration:none}li a:hover{color:var(--link-hover)}.post-date{color:var(--muted);font-size:0.9rem}p{margin:1em 0}code{background:var(--code-bg);border:1px solid var(--code-border);border-radius:4px;padding:2px 6px;font-family:'Consolas','Monaco','Courier New',monospace;font-size:0.9em;color:#e6e6e6}pre{background:var(--code-bg);border:1px solid var(--code-border);border-radius:6px;padding:16px;overflow-x:auto;margin:1.5em 0}pre::-webkit-scrollbar{height:6px}pre::-webkit-scrollbar-track{background:var(--code-bg)}pre::-webkit-scrollbar-thumb{background:var(--code-border);border-radius:3px}pre::-webkit-scrollbar-thumb:hover{background:var(--muted)}pre code{background:none;border:none;padding:0;font-size:0.875em;line-height:1.6}blockquote{border-left:3px solid var(--border);padding-left:1em;margin:1.5em 0;color:var(--muted);font-style:italic}a{color:var(--link);text-decoration:none}a:hover{color:var(--link-hover)}img{max-width:100%;height:auto;border-radius:4px;margin:1.5em 0}hr{border:none;border-top:1px solid var(--border);margin:2rem 0}table{width:100%;border-collapse:collapse;margin:1.5em 0}th,td{border:1px solid var(--border);padding:8px 12px;text-align:left}th{background:var(--code-bg);font-weight:500}article ul,article ol{list-style:initial;padding-left:2em;margin:1em 0}article li{margin:0.5em 0}footer{margin-top:3rem;padding-top:2rem;border-top:1px solid var(--border);text-align:center}.footer-logo{height:32px;width:auto;display:inline-block;opacity:0.6;transition:opacity 0.3s}.footer-logo:hover{opacity:1}</style><style> .search-container{ margin-bottom:32px; } .search-input{ width:100%; padding:10px 12px; background:var(--code-bg); border:1px solid var(--code-border); border-radius:6px; color:var(--fg); font-size:0.95rem; font-family:system-ui; } .search-input:focus{ outline:none; border-color:var(--link); } .search-results{ list-style:none; padding:0; margin:0; } .search-results li{ margin:0.8rem 0; } .no-results{ color:var(--muted); text-align:center; padding:2rem 0; } .search-info{ color:var(--muted); font-size:0.9rem; margin-bottom:1rem; } .search-preview{ color:var(--muted); font-size:0.85rem; margin-top:4px; line-height:1.5; } </style><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet"></head><body><h1>0u</h1><nav><a href="/">home</a><a href="/tags">tags</a><a href="/tree">tree</a><a href="/friends">friends</a><a href="/about">about</a><a href="/search">search</a></nav><div class="search-container"><input type="text" class="search-input" id="searchInput" placeholder="Search posts by title, date, or content..." autofocus></div><div class="search-info" id="searchInfo"></div><ul class="search-results" id="searchResults"></ul><script> const postsData = [{"title": "谈谈P2P内容分发网络", "date": "2024-11-30", "file": "posts/2024/11/谈谈P2P内容分发网络.html", "tags": ["网络", "隐私"], "content": "名词介绍\nP2P CDN（简称PCDN）是一种基于P2P技术的内容分发网络\n与传统的CDN不同，PCDN通过挖掘和利用边缘网络中的海量碎片化闲置资源，构建出一个低成本、高品质的内容分发网络服务\n在PCDN中，用户既是内容的消费者，也是内容的分发者\n当一个用户下载某个内容时，他可以从其他用户的节点中获取数据\n同时自己也作为节点为其他用户提供数据传输服务\n这种点对点的传输方式使得PCDN具有极高的扩展性和容错性\n能够在用户量激增的情况下仍保持稳定的性能\n相关技术\n对等式网络\n对等式网络（英语：peer-to-peer， 简称P2P），又称点对点技术，是去中心化、依靠用户群（peers）交换信息的互联网体系\n它的作用在于，减低以往网路传输中的节点，以降低资料遗失的风险\n与有中心服务器的中央网络系统不同，对等网络的每个用户端既是一个节点，也有服务器的功能，任何一个节点无法直接找到其他节点，必须依靠其户群进行信息交流\nP2P节点能遍布整个互联网，也给包括开发者在内的任何人、组织或政府带来监控难题\nP2P在网络隐私要求高和文件共享领域中，得到了广泛的应用\n使用一般型P2P技术的网络系统有比特币、G"}, {"title": "让你的 Git Commit Message 优雅起来", "date": "2025-10-02", "file": "posts/2025/10/让你的 Git Commit Message 优雅起来.html", "tags": ["Git", "编程", "杂谈", "开发"], "content": "\n“写代码一分钟，写 Commit Message 两行泪”\n—— 一位被历史代码支配的程序员\n\n为什么要在意 Commit Message ?\n想象一下，你正调试一个项目，git log 滚动出来的全是这样的信息: \n\nfix bug\nupdate\n123\nfinal_final_really_final\n\n\n是不是感觉灵魂受到了暴击? 半年后的你，根本不知道自己当时修了啥 bug，更别提帮别人 review 代码了\nCommit Message 就像项目的“日记”，写好它，团队能心有灵犀；写烂它，未来的自己会哭晕在厕所\n\n一点规范，大大不同\n业界其实早有共识，最常见的就是 Conventional Commits 规范\n它给 Commit Message 设计了一套语法，简单又高效:\n\n&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n\n\n例如: \n\nfeat(auth): 新增用户登录功能\nfix(api): 修复分页接口返回条数错误\ndocs(readme): 更新使用文档示例\n\n\n这样一眼扫过去，就能知道每个提交是 新增功能、修 bug"}, {"title": "绕过123pan的1G限制", "date": "2024-11-03", "file": "posts/2024/11/绕过123pan的1G限制.html", "tags": ["软件", "网络"], "content": "前言\nQ：这个脚本谁写的？\nA：不是我写的，脚本里面有注释，但是已经删库了。\nQ：有没有什么优化？\nA：没有，只删除了冗余的重复代码，改了一些函数调用。\nQ：怎么使用？\nA：物理机或者虚拟机上面下个123，自己抓包自己改脚本里面的???，不再提供现成UA。改完丢进油猴里面就行。\n// ==UserScript==\n// @name 123云盘下载辅助\n// @namespace https://github.com/Bao-qing/123pan\n// @version 0.3\n// @description 123 Cloud Drive Unlimited Flow\n// @match https://www.123pan.com/*\n// @match https://www.123pan.cn/*\n// @match https://www.123865.com/*\n// @match https://www.123684.com/*\n// @grant none\n// @a"}, {"title": "来自双十二的博客更新", "date": "2025-12-12", "file": "posts/2025/12/来自双十二的博客更新.html", "tags": ["博客", "迁移", "技术"], "content": "告别 VanBlog，拥抱 Astro\n双十二这天，终于把博客从 VanBlog 迁移到了基于 Astro 的静态博客系统\n其实这个想法已经酝酿很久了\n为什么离开 VanBlog\nVanBlog 确实是个不错的博客系统\n界面简洁、功能完善，还有后台管理面板\n但用久了总觉得有些不够灵活\n\n想要自定义样式？得改模板文件\n想要添加新功能？得深入源码\n部署方式相对固定，不够轻量\n\n作为一个喜欢折腾的人\n总想有更多的控制权\n为什么选择 Astro\nAstro 是一个静态站点生成器\n最大的特点是按需加载 JavaScript\n这意味着更快的页面加载速度\n更少的资源消耗\n而且：\n- 完全静态，部署简单\n- 基于 Markdown，内容管理方便\n- 可以自由定制主题和功能\n- 构建产物就是纯 HTML/CSS/JS，想放哪都行\n迁移过程\n迁移其实比想象中简单\n\n导出文章：VanBlog 支持导出 Markdown，直接拿到所有文章\n调整格式：统一 frontmatter 格式，添加必要的元数据\n迁移资源：把图片、附件等资源移到 public 目录\n自定义配置：调整主题色、导航栏、友链等\n部署上线：构建"}, {"title": "机器里的镜像：通过 AI 对话档案重构我的 2025", "date": "2025-12-17", "file": "posts/2025/12/机器里的镜像：通过 AI 对话档案重构我的 2025.html", "tags": ["年度总结", "AI", "技术", "思考", "自托管"], "content": "每到年底，我习惯翻看 GitHub 的 Commit 记录，或者检查服务器的 Uptime，甚至回顾账单\n但今年，我做了一个更有趣的尝试：我询问了陪伴我一整年的 AI，让它们根据后台的 真实可验证数据 和 长期观察 ，为我写一份年度总结\n收到的两份报告（一份来自 对话侧写档案 ，一份来自 时间线记录 ）令我惊讶\n它们不仅记录了代码和报错，更像是一面数字镜子，精准地折射出了我这一年的思维模式、工作节奏，甚至是我自己都未曾留意的执念\n这不是一份冰冷的统计报表，这是一份关于 我是谁 的数字证据\n01. 时间的形状：夜色中的思考者\n两份报告在我的活跃时间上达成了一种默契的共识\n\n白昼是战场： 在 UTC+8 的下午，我是执行者\n\n主要场景往往是开发中途，直接切入问题核心，贴出代码、结构或报错\n* 夜晚是航道： 真正的思维高峰出现在 20:00 到凌晨 01:00\nAI 指出，我几乎没有 清晨刚醒就聊天 的记录，也很少进行 寒暄型开场 \n我的对话节奏是 直切核心\n这不仅是工作习惯的体现，更像是一种生活隐喻：在喧嚣的白日里解决问题，在静谧的深夜里构建体系\n\n你不是来让我 陪你聊天 的\n你对 AI "}, {"title": "教育能让我们变得更好么", "date": "2024-12-17", "file": "posts/2024/12/教育能让我们变得更好么.html", "tags": ["杂谈"], "content": "孔子一向被中国人视为至圣先师，不仅才能广大，在道德上更是完人\n但这样一位圣人所教的弟子中，却出了帮助鲁国贵族季氏聚敛民财的冉有、恶意低毁同门的公伯寮\n东汉大儒郑玄，也是学问与道德上的典范\n为世人所重，黄巾军起，烧杀抢掠无所顾忌，但会刻意不去骚扰郑玄的故乡\n郑玄有一个弟子叫郗虑，却做出了令人大跌眼镜的事\n充当起曹操的枪手，罗织罪名将正直之士孔融置于死地\n冉有、郗虑等人所受的是当世最好的教育，犹且如此\n这基本可以得出一个结论：良好的教育，不一定能让人变得更好\n不过，如果就此否定教育的作用，显然会走向反智仇学的极端，典型表现就是读书无用论\n别以为在互联网高度发达的今日，读书无用论已丧失市场，其实抱持这种看法的人多得很\n尤其是那些做成一些事、赚到一些钱的人，他们大概曾经笃信教育对人有良好作用\n然而在做事过程中发现此前学的东西根本不敷用，于是举起大棒，把昔日信奉的理念捶了个粉碎\n如果这些人听说冉有、郗虑的故事，肯定喜出望外\n因为那些案例正是他们鄙薄教育的有力证据\n至于孔子、郑玄教出了众多杰出弟子，后市受孔子、郑玄影响的英伟士人不可胜数\n这些事实就被他们选择性地无视了\n即使如此，我们也不能骤然判决"}, {"title": "我想要一个域名，我该如何选购", "date": "2024-12-26", "file": "posts/2024/12/我想要一个域名，我该如何选购.html", "tags": ["域名", "网络", "杂谈"], "content": "\n本文章来自 Aurielの博客\n原文章地址请戳 Aurielの博客-新手建站（一）：从一个有意义的域名开始\n\n\n域名是什么？\n网域名称（英语：Domain Name，简称：Domain）\n简称域名、网域，是由一串用点分隔的字符组成的互联网上某一台电脑或电脑组的名称，用于在数据传输时标识电脑的电子方位\n域名可以说是一个IP地址的代称，目的是为了便于记忆后者\nIP地址是因特网主机的作为路由寻址用的数字体标识，不容易记忆\n因而产生了域名这一种字符型标识，它比IP地址更容易记忆\n这也是域名的一个重要功能——为数字化的互联网资源提供易于记忆的名称\n另外，域名具有唯一性，在资源更改IP地址时，只需要进行新IP地址与恒定域名的转换\n即可实现将资源移动到网络地址拓扑中的不同物理位置\n基于以上两个特性，域名还用于创建个体的唯一标识\n任何组织和个人在提供因特网资源时，都可以选择与其名称对应的域名，让其他人轻松访问这些资源\n域名的重要性\n选择一个合适的域名是进军网络世界的一个重要步骤\n网站用户会通过您的域名建立起对您的企业或组织的初步印象\n因此，一个令人印象深刻的域名有助于激发用户的兴趣并吸引 Web 流"}, {"title": "安卓私人DNS与代理中的DNS泄露问题探索", "date": "2024-11-07", "file": "posts/2024/11/安卓私人DNS与代理中的DNS泄露问题探索.html", "tags": ["网络", "隐私"], "content": "最近，我在研究安卓设备上私人DNS、代理软件与DNS泄露的问题，使用IPCheck.ing进行了多次测试，发现了一些有趣的现象。\n问题背景\n在使用代理软件时，启用国内的DoT会导致DNS泄露，而不使用DoT则可能暴露真实IP。此外，境外的许多DoT服务被屏蔽，增加了日常使用的复杂性。\n遇到的问题\n\n国内DoT与代理软件：\n当使用国内DoT时，代理软件可能导致DNS泄露，无法有效隐藏请求路径。\n不使用DoT的风险：\n如果不使用DoT，DNS请求会通过运营商的DNS，存在被监控和暴露真实IP的风险。\n境外DoT的局限性：\n由于许多境外DoT被屏蔽，无法使用，给网络体验带来困扰。\n\n问题根源\n这些问题主要源于安卓系统的限制。在启用私人DNS后，代理软件无法修改DNS设置，即使是AdGuard等知名软件也面临类似挑战。\n解决方案\n经过多次尝试，我找到了一种平衡的方法：\n把安卓私人DNS设置为dns.sb，这样可以有效避免DNS泄露。尽管在国内响应稍慢，但未被屏蔽，并能根据IP自动选择服务器。如果介意响应速度，日常使用时可以切换到国内的DoT；需要更高安全时，再切换到DNS.sb。\n通过这些调整"}, {"title": "如何找到适合你的软件", "date": "2024-11-21", "file": "posts/2024/11/如何找到适合你的软件.html", "tags": ["软件", "杂谈"], "content": "我一向不喜欢做一名所谓的“传教者”，向你推荐哪个软件好用，哪个软件比哪个软件好用，做什么事有什么好的软件可以实现\n很多时候别人问我类似的软件推荐需求时，我都尽量避免回答\n有些很棒的软件，要么是你给他装上去之后他一次都不用，要么是他坚持着自己的使用习惯\n对于大多数人而言，切换了一个新的平台，第一时间想的却是以前的各种使用习惯，如果改变过大，便会抱怨……\n于是也就有了以下的文字：（全部以文本编辑器为例）\n一、弄清软件定义\n这个软件主要用来做的是什么？\n比如，文本编辑器，维基百科这样定义：\n\n文本编辑器是计算机软件中的一种\n主要用于用来编写和查看文本文件\n有一些特殊的文本编辑器支持增加自有的格式来丰富文档的表现形式\n操作系统或者集成开发环境通常会带有可以查看和编辑纯文本的编辑器\n可增加格式的文本编辑器通常是个人用户或者公司在制作需要格式的文件中使用\n\nPS，记事本真心不适合写代码，尤其是 PHP 代码 ;)\n二、你真的弄清楚了？\n\n你现在的系统上有多少常见的文本编辑器，你能列举多少个？\n它们每个的特点又是如何，你能说出一两个它们的优缺点么？\n百度、谷歌之后，你能说出哪个该用来写代码，哪个该用"}, {"title": "在 AI 时代把信息碎片变成可用知识：构建个人知识体系的六步法", "date": "2025-12-31", "file": "posts/2025/12/在AI时代把信息碎片变成可用知识.html", "tags": ["知识管理", "学习", "AI"], "content": "在人工智能与海量信息并行涌现的时代，个人若要持续提升、保持创造力，必须把碎片化的信息转化为可用的知识\n我会提出一个简洁的六步法，帮助你从捕捉到分享，建立一个可持续自我升级的个人知识体系。\n六步法概览\n- 捕捉与筛选\n- 结构化笔记\n- 知识网络\n- 实践与产出\n- 审视与更新\n- 分享与反馈\n逐步落地\n1) 捕捉与筛选\n- 做法要点：随时捕捉新信息，优先记录对你当前目标有潜在价值的要点；建立“记录-筛选-存档”的三段式流程。\n- 工具与格式：笔记软件（如 Obsidian、Notion、Bear 等）的快速笔记、简短要点、引用来源、关键信息标签。\n- 注意事项：避免盲目堆积，记录时附上上下文与来源，便于后续筛选与回溯。\n2) 结构化笔记\n- 做法要点：用层级、标签、链接把笔记组织成可导航的结构，优先建立概念-关系-案例的三元结构。\n- 工具与格式：双向链接（或反向链接）、概念卡片、简短摘要与关键公式/图示。\n- 注意事项：避免信息孤岛，确保每条笔记能独立理解，并能与其他笔记连接。\n3) 知识网络\n- 做法要点：建立跨领域的联系，把相关领域的要点连接起来，形成网络化的知识图谱。\n- 工具"}, {"title": "国内外DNS列表", "date": "2024-11-09", "file": "posts/2024/11/国内外DNS列表.html", "tags": ["隐私", "网络"], "content": "国内外知名免费公共DoT/DoH加密DNS服务器(含IPV6)\n注意\n\n\n\n加密DNS传输过程中第三方无法查看\n无法污染DNS结果不代表DNS服务器本身不作恶\n\n\n在国内使用国外加密DNS有可能无法上网\n能使用8.8.8.8上网不代表 DoH(https://8.8.8.8/dns-query) 就可以访问\n经测试大多数国外DoH在国内都被屏蔽\n能使用的解析速度也很慢\n\n\n\n阿里公共DNS\nIPv4:\n223.5.5.5\n223.6.6.6\n\nIPv6:\n2400:3200::1\n2400:3200:baba::1\n\nDoH:\nhttps://223.5.5.5/dns-query\nhttps://223.6.6.6/dns-query\nhttps://dns.alidns.com/dns-query\n\nDoT:\ndns.alidns.com\n23.5.5.5\n223.6.6.6\n\n腾讯公共DNS(DNSPod)\nIPv4:\n119.29.29.29\n\nIPV6:\n2402:4e00::\n\nDoH:\nhttps://doh.pub/dns-query\nhttps://1.12.12.1"}, {"title": "国内npm源镜像", "date": "2024-11-16", "file": "posts/2024/11/国内npm源镜像.html", "tags": ["开发", "网络"], "content": "\n国内npm源镜像（npm加速下载） 指定npm镜像\n\n国内npm源镜像\n指定npm镜像\n\n\n\nNPM镜像提供方\nNPM镜像地址\n\n\n\n\nNPM官方\nhttps://registry.npmjs.org/\n\n\n淘宝\nhttps://registry.npm.taobao.org/\n\n\n阿里云\nhttps://npm.aliyun.com/\n\n\n腾讯云\nhttps://mirrors.cloud.tencent.com/npm/\n\n\n华为云\nhttps://mirrors.huaweicloud.com/repository/npm/\n\n\n网易\nhttps://mirrors.163.com/npm/\n\n\n中科院大学\nhttp://mirrors.ustc.edu.cn/\n\n\n清华大学\nhttps://mirrors.tuna.tsinghua.edu.cn/\n\n\n\n切换源\nnpm config set registry 源的地址\n\n查看当前的镜像源\nnpm config get registry\n\n推荐使用上面的方式指定npm镜像，当然方法不唯一，也可以用 nrm 去指定npm镜像\n什"}, {"title": "写码三境界", "date": "2024-11-22", "file": "posts/2024/11/写码三境界.html", "tags": ["杂谈", "开发"], "content": "写码三境界：\n\n由少写多 (开始懂得写代码)\n由多写少 (有意识地精简优化逻辑)\n由少写多 (理解抽象设计)\n\n很多人停留在第一阶段，也就是能写出来，能用\n但是代码逻辑不精简，质量一般，同时杂乱无章\n典型的特点是写之前毫无想法，随想随写\n第二阶段是指，有意识地去精简逻辑，简化思路\n但是代码因为刻意地精简，反而不好维护\n写出来的很多细节异常考虑均不到位。很多人甚至走上刻意追求简洁的道路，写出极其难看的面条代码\n第三阶段，写之前需求清晰，考虑到了各种未来扩展可能，适度抽象，逻辑条理\n好的代码，不一定是最简洁的代码，但一定是最好维护的代码，同时也是最好扩展的代码\n所以，我发现一个特点，好代码，其编程风格都是相似的\n写代码关键在于思路，在于你想要什么，要写什么\n没想法写出来的代码，再好看都没用"}, {"title": "关于为什么站点沉寂这么久", "date": "2025-11-08", "file": "posts/2025/11/关于为什么站点沉寂这么久.html", "tags": ["杂谈"], "content": "服务器复活记\n大约一个月前的某个夜晚，服务器彻底“睡死”了\n原本计划只是例行重启，结果第二天早上打开面板——引导没了\n系统直接报错，连救援模式都进不去。那一刻我明白\n是时候放它休息一下了\n当时想着“反正快考试了，等考完再修”\n结果这一拖，就变成了一个月\n期间偶尔路过机架，看到那盏永远暗着的电源灯\n心里还是有点不是滋味\n这次索性趁空档彻底重装了一遍系统\n从 Windows Server 回到了 Linux\n主要是 Windows 的远程维护实在麻烦\n服务部署、权限管理、自动化脚本都不如 Linux 顺手\n于是重新分区、重建引导、装上 Debian\n接着恢复 Docker 环境、容器网络和挂载卷\n几个小时后，熟悉的命令行再次出现在屏幕上\n那一刻只有一个想法：\n\n“至少它复活了”\n\n目前一切运行良好，服务比之前更干净、轻量，\n顺便也清理了很多旧配置\n算是一次意外的系统重生"}, {"title": "使用MSF抓取用户密码", "date": "2024-10-23", "file": "posts/2024/10/使用MSF抓取用户密码.html", "tags": ["安全", "Linux"], "content": "抓取自动登录的密码\n很多用户习惯将计算机设置自动登录\n可以使用\nrun windows/gather/credentials/windows_autologin\n\n抓取自动登录的用户名和密码\n导出密码哈希\nrun hashdump 命令\n\nhashdump 模块可以从 SAM数据库 中导出本地用户账号，该命令的使用需要系统权限\n\n\n在 meterpreter_shell 中执行 run hashdump 命令\n\nrun hashdump\n\n\n用户哈希数据的输出格式为\n\n用户名:SID:LM哈希:NTLM哈希:::\n\n\n\n使用在线网站解密hash密码\nCMD5\n\n\nrun windows/gather/smart_hashdump 命令\n\n使用需要系统权限。该功能更强大\n如果当前用户是域管理员用户\n则可以导出域内所有用户的 hash\n\n\n\n使用 mimikatx 抓取密码\n上传 mimikatz 程序\n我们可以通过上传 mimikatz 程序\n然后执行 mimikatz 程序来获取明文密码\n\n\n前提\n执行 mimikatz 必须 System 权限\n并且在执行时，要根据当前的系统位数进行"}, {"title": "为 Linux 服务器配置密钥登录与 VSCode 免密远程连接", "date": "2025-11-28", "file": "posts/2025/11/为 Linux 服务器配置密钥登录与 VSCode 免密远程连接.html", "tags": ["Linux", "安全", "网络"], "content": "如何在本地生成 SSH 密钥并将公钥添加到服务器，实现无密码（密钥）登录 Linux\n生成密钥\n使用工具 ssh-keygen 生成一对私钥与公钥\nWindows 10/11 理论上已内置 OpenSSH 组件，可以直接使用此命令\n没有的话也可以装一个 Git 然后用 Git Bash\n或者在 系统设置 -&gt; 应用 -&gt; 可选功能 -&gt; 添加可选功能 中安装 OpenSSH 客户端并重启\n使用以下命令生成密钥\nssh-keygen -t rsa\n\n\n想要实现免密登录需要将密码短语（passphrase）留空\n\n执行完成后可以获得一个私钥文件 id_rsa 与一个公钥文件 id_rsa.pub\n将私钥文件备份好，防止遗失或泄露，打开公钥文件，将其中的内容复制到剪切板\n导入密钥\n登录 Linux 服务器，打开 /etc/ssh/sshd_config 文件\n取消 PubkeyAuthentication 的注释（删除 #，如不存在此项可以在文件末尾手动添加），并确保其值为 yes，可开启密钥登录\nPubkeyAuthentication yes\n\n（可选）将 Passwo"}, {"title": "一道无趣的面试编程题", "date": "2025-01-09", "file": "posts/2025/01/一道无趣的面试编程题.html", "tags": ["面试", "编程", "算法"], "content": "最近经济大环境依旧没能从疫情中走出来，身边有不少小伙伴被裁员或者是公司倒闭失业\n好友群里讨论最多的话题就是面试，自然少不了讨论面试题\n昨天一位相识多年的好友发我了一道面试题，他当时正好在面试，需要现场编程\n当时刚好不忙就看了一下题目，感觉很无趣\n但还是耐着性子文字给他讲了讲，顺带着画了张简图，可是他还是没懂\n原题如下：\n\n一个城市可以近似看成 n * m 的网格图，A 公司有 k 个维修点，每个维修点有固定的坐标，城市里面有 h 个客户需要修理手机，客户有固定的坐标\n维修员在地图上只能上下左右走，不能斜着走，每走一个格子需要 2 块钱的花费\n每个维修点拥有无数个员工，每个员工可以被派去为一个客户服务\n城市里面有 z 个地方在修理管道，这些地方是不能走的\n可能有一些客户是被隔离的（上下左右都在修管道），这里是不需要派员工去修理手机了\nA 公司为了节省财力，想找到最小的花费\n输入：\n第一行给出两个正整数 n, m （0 &lt; n &lt; 1000, 0 &lt; m &lt; 1000）\n第二行给出 k（0 &lt; k &lt; 20）以及 k 个维修点的坐标\n第三行给出 z（0 "}, {"title": "一段代码将网站变为黑白", "date": "2024-10-25", "file": "posts/2024/10/一段代码将网站变为黑白.html", "tags": ["开发", "前端"], "content": "本教程理论上适用于所有网页\n\n最终效果在此省略\n\n在网页的 &lt;/head&gt; 前添加以下代码\n若想要全站变为黑白，可修改 head.ejs 模板文件（不同主题略有不同）\n&lt;style&gt;\nhtml {\n filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);\n -webkit-filter: grayscale(100%);\n}\n&lt;/style&gt;\n"}, {"title": "sed 命令入门", "date": "2025-09-09", "file": "posts/2025/09/sed 命令入门.html", "tags": ["Linux", "软件"], "content": "sed 是文本处理三剑客之一\n掌握它能能很有效地提高我们的效率\n\n首先\n阅读之前，我觉得你应该有：\n1. 命令行基础（懂得如何打开 cmd 和使用命令）\n2. sed 可以在 Linux 或 Git Bash 下运行\n3. 了解使用 Linux 或 Git\n4. 知道什么是 cat 命令\n5. 正则表达式的基础\nsed 介绍\nsed 是什么？\n\nawk、grep、sed 是 linux 操作文本的三大利器，合称文本三剑客，也是必须掌握的 linux 命令之一\n三者的功能都是处理文本，但侧重点各不相同，其中属 awk 功能最强大，但也最复杂\ngrep 更适合单纯的查找或匹配文本\nsed 更适合编辑匹配到的文本\nawk 更适合格式化文本，对文本进行较复杂格式处理\n\nsed 的工作原理：在处理文本时逐行读取文件内容，读到匹配的行就根据指令做操作，不匹配就跳过\n调用 sed 命令的语法有两种：\n\n在命令行指定 sed 指令对文本进行处理：sed + 选项 '指令' 文件\n先将 sed 指令保存到文件中，将该文件作为参数进行调用， sed + 选项 -f 包含sed指令的文件 文件\n\n以下选项看"}, {"title": "htaccess文件格式", "date": "2025-04-29", "file": "posts/2025/04/htaccess文件格式.html", "tags": ["开发", "Linux", "前端", "网络"], "content": "\nhtaccess文件简介\nhtaccess文件是Apache服务器中的一个配置文件，负责相关目录下的网页配置\n/www/html下的.htaccess文件与主配置文件中段中内容完全等效\n.htaccess文件中的配置指令作用于.htaccess文件所在的目录及其所有子目录\n且子目录中的指令会覆盖父目录或者主配置文件中的指令\nrewrite的语法格式：\n\nRewriteEngine On #启用rewrite起作用。\nRewriteBase url-path #设定基准目录。\nRewriteCond test-string condPattern #用于测试rewrite的匹配条件。\nRewriteRule Pattern Substitution #规则\n\nRewriteEngine On|Off\nRewriteEngine 用于开启或停用rewrite功能。rewrite configurations 不会自动继承\nRewriteBase URL-path\nRewriteBase用于设定重写的基准URL\nRewriteRule可以用于目录级的配置文件中 (.htaccess)并在局"}, {"title": "hello", "date": "2024-01-01", "file": "posts/2024/01/hello.html", "tags": ["system", "silent", "notes"], "content": "this site exists.\nit is not a platform.\nit is not a product.\nit is not an archive.\nit is a place where text runs\nand stays.\nno comments.\nno timeline.\nno obligation to update.\nif you are reading this,\nthe system is working."}, {"title": "RSA加密算法简介", "date": "2025-08-07", "file": "posts/2025/08/RSA加密算法简介.html", "tags": ["RSA", "杂谈", "密码学", "安全"], "content": "概述\nRSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中被广泛使用。RSA是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在1977年一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的\n前置知识\n欧拉函数\n在数论中，对正整数n，欧拉函数$\\displaystyle \\varphi (n)$是小于等于$\\displaystyle n$的正整数中与$\\displaystyle n$互质的数的数目。例如$\\displaystyle \\varphi \\left(8\\right)=4$，因为1、3、5和7均与8互质。\n欧拉函数是积性函数，即是说若$\\displaystyle m,n$互质，则：\n$$\\displaystyle \\varphi (mn)=\\varphi (m)\\varphi (n)\n$$\n使用中国剩余定理有较简略的证明：设$\\displaystyle A,B,C$是跟$\\displaystyle m,n ,mn$互质的数的集，据中国剩余定理，$\\d"}, {"title": "Pandora-Box使用教程", "date": "2024-11-02", "file": "posts/2024/11/Pandora-Box使用教程.html", "tags": ["软件", "隐私"], "content": "1、Pandora-Box 是什么？\n\n一个简易的 Mihomo 桌面客户端，可以进行网络代理\n\n爬取功能可以管理大量订阅节点，支持对节点的协议类型和国家地区筛选，支持将爬取的节点导出\n\n\nWindows 最新版本 windows-amd64.zip \n\nMac intel 处理器最新版本 darwin-amd64.zip\nMac M 处理器最新版本 darwin-arm64.zip\n\n2、本文重点介绍其爬取的使用，其他的自行探索\nPandora-Box：下文简称pb\n2.1、爬取原理是什么？\n没看源码，个人猜测\npb会根据你输入的url地址，发起网络请求\n对请求的内容进行解析，然后收集整理出各个类型的节点\n再进一步去重后使用 Mihomo 进行节点可用性的检测\n2.2、爬取之前为什么需要准备个可以富强的订阅？\n因为你爬取的内容可能需要富强，比如github。\n2.3、爬取之前为什么需要退出其他代理软件？\n为了不影响节点可用性的检测\n3、具体操作步骤\n3.1、在配置中导入预先准备的订阅，然后选中\n如果没有可自购或者在GitHub搜索节点抓取\n3.2、在抓取中导入要抓取的URL地址\n3."}, {"title": "MSF使用教程", "date": "2024-10-24", "file": "posts/2024/10/MSF使用教程.html", "tags": ["安全", "Linux"], "content": "Metasploit Framework\n\n实验环境\n简介\nMetasploit 的安装和更新升级\n一键安装MSF\nMSF 的更新升级\n非 kali 环境下更新升级 MSF\nkali 环境下更新升级 MSF\n\n\n使用方法\n基础使用\nMSF 中加载自定义的 exploit 模块\n漏洞利用 (exploit)\n攻击载荷 (payload)\n 4.1 payload 模块路径\n 4.2 Metasploit 中的 Payload 模块主要有以下三种类型\nMeterpreter\n 5.1 Meterpreter 是如何工作的？\n 5.2 Meterpreter 的特点\nMS17_010 (永恒之蓝)\n 6.1 查找漏洞相关模块\n 6.2 利用 Auxiliary 辅助探测模块 对漏洞进行探测\n 6.3 使用 Exploit 漏洞利用模块 对漏洞进行利用\n 6.4 Payload 攻击载荷模块\n后渗透阶段\n 7.1 Post 后渗透模块\n 7.2 查看主机是否运行在虚拟机上\n 7.3 关闭杀毒软件\n "}, {"title": "JavaScript飞雪特效", "date": "2024-12-03", "file": "posts/2024/12/JavaScript飞雪特效.html", "tags": ["开发", "前端", "JavaScript"], "content": "马上就要到了传统节日“春节”?\n网站添加了飞雪❄️特效\n从网上找了源代码\n你可以复制到自己的网站或者博客体验一波\n&lt;script&gt;\n(function($){\n $.fn.snow = function(options){\n var $flake = $('&lt;div id=&quot;snowbox&quot; /&gt;').css({'position': 'absolute','z-index':'9999', 'top': '-50px'}).html('❄'),\n documentHeight = $(document).height(),\n documentWidth = $(document).width(),\n defaults = {\n minSize : 6,\n maxSize : 10,\n newOn : 1000,\n flakeColor : &quot;#FFFFFF&quot; /* 此处可以定义雪花颜色 */\n },\n options = $.extend({}, defaults, options);\n var inte"}, {"title": "JavaScript中forEach方法的async/await异步问题", "date": "2025-03-11", "file": "posts/2025/03/JavaScript中forEach方法的async_await异步问题.html", "tags": ["开发", "前端", "JavaScript"], "content": "最近在用Node JS写个小项目的时候发现了一个之前没有注意过的问题\n数组使用forEach方法进行异步操作时执行顺序可能会出现问题\n这篇文章就来简单谈一谈产生这个问题具体原因以及解决方法\n问题描述\n当时遇到的问题与SQL写入操作有关，简化一下相当于：\nvar numList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\nnumList.forEach(async (e)=&gt;{\n await new Promise((res, rej)=&gt;{\n //模拟一个耗时不确定的异步过程\n setTimeout(()=&gt;{\n console.log(e)\n res(e);\n }, Math.random()*1000); \n });\n});\n\n本来期望的是使用await来阻塞异步函数，使其按循环顺序得到结果\n但实际得到的却是一个随机的数列\n下面来分析一下原因\nfor循环中的情况\n将上面的代码用for循环改写得到\nvar numList = [1, 2, 3"}, {"title": "Git常用命令汇总", "date": "2024-12-28", "file": "posts/2024/12/Git常用命令汇总.html", "tags": ["Git", "网络", "开发", "软件"], "content": "教你使用 Git 基本操作\n常规操作\n\ngit push origin test 推送本地分支到远程仓库\ngit rm -r --cached 文件/文件夹名字 取消文件被版本控制\ngit reflog 获取执行过的命令\ngit log --graph 查看分支合并图\ngit merge --no-ff -m '合并描述' 分支名不使用 Fast forward 方式合并，采用这种方式合并可以看到合并记录\ngit check-ignore -v 文件名 查看忽略规则\ngit add -f 文件名 强制将文件提交\n\nGit 创建项目仓库\n\ngit init 初始化\ngit remote add origin url 关联远程仓库\ngit pull\ngit fetch 获取远程仓库中所有的分支到本地\n\n忽略已加入到版本库中的文件\n\ngit update-index --assume-unchanged file 忽略单个文件\ngit rm -r --cached 文件/文件夹名字 (. 忽略全部文件)\n\n取消忽略文件\n\ngit update-index --no-assume-unchan"}, {"title": "Docker入门系列 (9) - 容器数据卷与持久化存储", "date": "2025-09-29", "file": "posts/2025/09/Docker入门系列 (9) - 容器数据卷与持久化存储.html", "tags": ["Linux", "开发", "Docker"], "content": "容器是临时的，但数据不是\n本章将深入讲解 Docker 的数据管理机制，重点介绍 Volume（数据卷）的使用方式、挂载策略与最佳实践，帮助你实现容器间的数据共享与持久化存储\n\n为什么需要数据卷\n默认情况下，容器中的数据会随着容器销毁而丢失\n为了解决数据持久化与共享问题，Docker 提供了三种挂载方式：\n\nVolume：由 Docker 管理的挂载点，推荐使用\nBind Mount：将宿主机目录挂载到容器中，灵活但不隔离\ntmpfs：将数据存储在内存中，适用于敏感或临时数据\n\n\n使用 Volume 的基本方式\n创建数据卷：\ndocker volume create mydata\n\n查看卷列表：\ndocker volume ls\n\n挂载卷到容器：\ndocker run -d -v mydata:/app/data nginx\n\n容器中的 /app/data 目录将映射到 mydata 卷中\n\nBind Mount 示例\n将宿主机目录挂载到容器：\ndocker run -d -v /home/user/config:/etc/nginx nginx\n\n适用于配置文件、日志文件等需要直接访"}, {"title": "Docker入门系列 (8) - Dockerfile进阶与构建优化", "date": "2025-09-28", "file": "posts/2025/09/Docker入门系列 (8) - Dockerfile进阶与构建优化.html", "tags": ["Linux", "开发", "Docker"], "content": "Dockerfile 是构建镜像的核心脚本，它定义了容器的运行环境、依赖、启动方式等内容\n本章将深入讲解 Dockerfile 的高级指令、构建优化技巧以及多阶段构建的实战应用，帮助你构建更高效、更安全的镜像\n\nDockerfile 回顾\n一个基础的 Dockerfile 示例：\nFROM node:18\nWORKDIR /app\nCOPY . .\nRUN npm install\nCMD [&quot;npm&quot;, &quot;start&quot;]\n\n\n常用指令详解\n\n\n\n指令\n说明\n\n\n\n\nFROM\n指定基础镜像\n\n\nRUN\n执行命令（如安装依赖）\n\n\nCOPY / ADD\n拷贝文件到镜像中\n\n\nWORKDIR\n设置工作目录\n\n\nCMD / ENTRYPOINT\n设置容器启动命令\n\n\nENV\n设置环境变量\n\n\nEXPOSE\n声明端口（仅文档作用）\n\n\nVOLUME\n声明挂载点\n\n\nLABEL\n添加元数据\n\n\n\n\n构建优化技巧\n减少镜像层数\n将多个命令合并为一条：\nRUN apt-get update &amp;&amp; apt-get install -y curl g"}, {"title": "Docker入门系列 (7) - Docker 与 Kubernetes 集成", "date": "2025-09-27", "file": "posts/2025/09/Docker入门系列 (7) - Docker 与 Kubernetes 集成.html", "tags": ["Linux", "开发", "Docker"], "content": "随着容器技术的发展，Kubernetes（简称 K8s）已成为容器编排的事实标准\n本章将介绍如何将 Docker 与 Kubernetes 集成，理解两者的关系，并完成一个基础的容器部署示例\n\n为什么选择 Kubernetes\n虽然 Docker Swarm 提供了基本的容器编排能力，但 Kubernetes 拥有更强大的功能和更广泛的社区支持：\n\n自动化部署与回滚\n服务发现与负载均衡\n弹性伸缩与资源调度\n健康检查与自愈机制\n丰富的生态系统与插件支持\n\n\nDocker 与 Kubernetes 的关系\n\nDocker 是容器运行时，负责构建和运行容器\nKubernetes 是容器编排平台，负责调度和管理容器集群\nKubernetes 可使用 Docker 作为底层运行时（也支持其他如 containerd）\n\n\n环境准备\n推荐使用以下方式快速体验 Kubernetes：\n\nMinikube：本地单节点 Kubernetes 集群\nKind：基于 Docker 的 Kubernetes 集群\nK3s：轻量级 Kubernetes，适合边缘设备\n\n安装 Minikube 示例：\nbrew "}, {"title": "Docker入门系列 (6) - CI/CD 与 Jenkins 实践", "date": "2025-09-26", "file": "posts/2025/09/Docker入门系列 (6) - CI_CD 与 Jenkins 实践.html", "tags": ["Linux", "开发", "Docker"], "content": "在现代软件开发流程中，持续集成（CI）与持续部署（CD）已成为 DevOps 的核心实践\n本章将介绍如何使用 Jenkins 与 Docker 构建自动化流水线，实现从代码提交到容器部署的全流程自动化\n\n什么是 CI/CD\n\n持续集成（CI）：开发者频繁地将代码集成到主分支，并自动进行构建与测试\n持续部署（CD）：将通过测试的代码自动部署到生产环境或测试环境\n\nCI/CD 能显著提升开发效率、减少人为错误，并加快产品迭代速度\n\nJenkins 简介\nJenkins 是一个开源的自动化服务器，支持构建、测试、部署等任务\n它拥有丰富的插件生态，能够与 Docker、Git、Kubernetes 等工具无缝集成\n\n环境准备\n\n安装 Docker\n使用 Docker 启动 Jenkins：\n\ndocker run -d \\\n --name jenkins \\\n -p 8080:8080 -p 50000:50000 \\\n -v jenkins_home:/var/jenkins_home \\\n jenkins/jenkins:lts\n\n\n访问 Jenkins：http://localh"}, {"title": "Docker入门系列 (5) - Docker Swarm", "date": "2025-09-25", "file": "posts/2025/09/Docker入门系列 (5) - Docker Swarm.html", "tags": ["Linux", "开发", "Docker"], "content": "在前几章中，我们已经掌握了 Docker 的基础命令、网络原理以及 Compose 的服务编排能力\n本章将深入讲解 Docker Swarm —— Docker 官方提供的原生容器集群管理工具\nSwarm 能够将多台主机组织成一个统一的集群，实现服务的高可用、自动调度与负载均衡\n\n什么是 Docker Swarm\nDocker Swarm 是 Docker 内置的集群管理与编排工具\n它允许你将多个 Docker 主机组成一个集群，并在其中部署分布式服务\nSwarm 提供了服务发现、负载均衡、滚动更新等功能，是构建生产级容器平台的重要组件\n\nSwarm 的核心概念\n\n节点（Node）：Swarm 集群中的主机，分为管理节点（Manager）和工作节点（Worker）\n服务（Service）：Swarm 中运行的容器任务集合，具备副本数、更新策略等配置\n任务（Task）：服务的具体运行实例，分配给某个节点执行\n覆盖网络（Overlay Network）：用于跨主机容器通信的虚拟网络\n\n\n初始化 Swarm 集群\n在一台主机上执行：\ndocker swarm init\n\n输出中会包含加入集群"}, {"title": "Docker入门系列 (4) - Docker Compose详解", "date": "2025-09-24", "file": "posts/2025/09/Docker入门系列 (4) - Docker Compose详解.html", "tags": ["Linux", "开发", "Docker"], "content": "在前几章中，我们已经了解了 Docker 的基本命令、镜像与容器管理以及网络原理。本章将深入讲解 Docker Compose —— 一个用于定义和运行多容器 Docker 应用的工具。通过 Compose，你可以用一份配置文件描述整个应用的服务栈，实现一键部署与管理\n\n什么是 Docker Compose\nDocker Compose 是一个用于定义和运行多容器应用的工具。它通过 docker-compose.yml 文件描述服务、网络、卷等配置，并通过简单命令完成构建、启动、停止等操作。\n\nCompose 的核心概念\n\n服务（services）：每个服务对应一个容器，可以指定镜像、命令、端口等\n网络（networks）：服务之间的通信依赖网络配置，默认自动创建\n卷（volumes）：用于持久化数据或共享文件\n依赖（depends_on）：定义服务之间的启动顺序\n\n\n一个最小的 Compose 示例\nversion: '3'\nservices:\n web:\n image: nginx\n ports:\n - &quot;8080:80&quot;\n\n启动服务：\n"}, {"title": "Docker入门系列 (3) - Docker 网络原理详解", "date": "2025-09-23", "file": "posts/2025/09/Docker入门系列 (3) - Docker 网络原理详解.html", "tags": ["Linux", "开发", "Docker"], "content": "容器之间如何通信？容器如何暴露服务给外部？Docker 网络是容器化部署中不可忽视的一环。本章将深入解析 Docker 的网络模型、常见网络类型及其应用场景，帮助你构建更稳定、可控的容器网络环境。\n\n网络模型概览\nDocker 提供了多种网络驱动，满足不同场景下的容器通信需求：\n\nbridge：默认网络，适用于单主机容器通信\nhost：容器共享宿主机网络栈，性能高但隔离性弱\nnone：容器无网络连接，适用于完全隔离场景\noverlay：跨主机容器通信，适用于 Swarm 集群\nmacvlan：容器拥有独立 IP，适用于与物理网络集成\n\n\nbridge 网络详解\n\nDocker 默认创建一个名为 bridge 的虚拟网桥\n所有未指定网络的容器都会连接到该网桥\n容器之间可通过名称互相访问\n可使用 docker network inspect bridge 查看网络详情\n\n示例：\ndocker run -d --name web1 nginx\ndocker run -d --name web2 nginx\ndocker exec -it web1 ping web2\n\n\nhost 网络模式\n"}, {"title": "Docker入门系列 (2) - 学习路线", "date": "2025-09-22", "file": "posts/2025/09/Docker入门系列 (2) - 学习路线.html", "tags": ["Linux", "开发", "Docker"], "content": "在当今云原生和微服务盛行的时代，Docker 已成为开发者和运维人员不可或缺的技能之一。本文将为你梳理一条清晰的 Docker 学习路线，帮助你从零开始，逐步掌握容器技术的核心知识与实战能力。\n\n学习路线总览\nDocker 的学习可以分为以下几个阶段：\n\n\n\n阶段\n内容\n目标\n\n\n\n\n入门\nDocker 概述、安装、基本命令\n了解 Docker 的基本概念与使用方式\n\n\n进阶\n镜像管理、容器操作、数据卷、Dockerfile\n掌握容器构建与数据持久化\n\n\n实战\n网络原理、IDE 整合、Compose、Swarm\n构建复杂应用、实现服务编排\n\n\nDevOps\nCI/CD 与 Jenkins 集成\n实现自动化部署与持续交付\n\n\n\n\n第一阶段：Docker 入门\nDocker 概述\n\n什么是容器技术？\nDocker 与虚拟机的区别\nDocker 的应用场景\n\nDocker 安装\n\nWindows / macOS / Linux 安装指南\n使用 Docker Desktop\n\nDocker 基本命令\n\n镜像命令：docker pull, docker images, docker rmi\n容器"}, {"title": "Docker入门系列 (15) - 项目实战总结与部署策略", "date": "2025-10-05", "file": "posts/2025/10/Docker入门系列 (15) - 项目实战总结与部署策略.html", "tags": ["Linux", "开发", "Docker"], "content": "经过前十四章的学习，我们已经掌握了 Docker 的核心概念、工具链、编排方式与安全实践\n本章将以项目实战为背景，总结从开发到部署的完整流程，并介绍多环境部署、自动化构建与云端部署策略，帮助你将 Docker 技术真正应用到生产环境中\n\n项目结构建议\n一个典型的 Docker 项目结构：\nmyapp/\n├── docker-compose.yml\n├── Dockerfile\n├── .dockerignore\n├── .env\n├── scripts/\n│ └── build.sh\n├── services/\n│ ├── frontend/\n│ ├── backend/\n│ └── db/\n\n\nDockerfile：定义镜像构建方式 \ndocker-compose.yml：定义服务栈 \n.env：环境变量配置 \nscripts/：自动化脚本 \nservices/：按模块拆分服务目录 \n\n\n多环境部署策略\n使用 Compose 的多文件合并功能：\ndocker-compose -f docker-compose.yml -f docker-compose.pr"}, {"title": "Docker入门系列 (14) - Docker 安全实践与镜像加固", "date": "2025-10-04", "file": "posts/2025/10/Docker入门系列 (14) - Docker 安全实践与镜像加固.html", "tags": ["Linux", "开发", "Docker"], "content": "容器技术虽然提升了部署效率，但也带来了新的安全挑战\n本章将介绍 Docker 的安全实践，包括镜像加固、权限控制、漏洞扫描与网络隔离，帮助你构建更安全的容器运行环境\n\n容器安全的核心问题\n\n\n\n问题\n风险\n\n\n\n\n镜像来源不可信\n恶意代码、后门\n\n\n使用 root 用户运行\n权限过高，易被攻击\n\n\n镜像体积过大\n增加攻击面与构建时间\n\n\n网络暴露过多端口\n易遭扫描与攻击\n\n\n缺乏漏洞检测\n隐藏安全隐患\n\n\n\n\n镜像加固建议\n使用可信镜像源\n\n优先使用官方镜像或企业认证镜像\n避免使用 latest 标签，锁定版本号\n\nFROM nginx:1.25.2\n\n镜像瘦身\n\n使用轻量基础镜像，如 alpine\n\nFROM node:18-alpine\n\n\n清理构建缓存与临时文件\n\nRUN apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n\n最小权限原则\n避免使用 root 用户\nRUN addgroup -S appgroup &amp;&amp; adduser -S appuser -G appgroup\nUSER appuser\n\n"}, {"title": "Docker入门系列 (13) - Docker 跨平台开发环境构建", "date": "2025-10-03", "file": "posts/2025/10/Docker入门系列 (13) - Docker 跨平台开发环境构建.html", "tags": ["Linux", "开发", "Docker"], "content": "在团队协作与多平台开发中，环境不一致常常导致“在我电脑上能跑”的问题\nDocker 提供了构建统一开发环境的能力，使得 Windows、macOS、Linux 用户都能在一致的容器环境中开发、调试与运行项目\n本章将介绍如何使用 Docker 构建跨平台开发环境，提升协作效率与可移植性\n\n为什么使用 Docker 构建开发环境\n\n避免环境污染与依赖冲突\n快速切换项目环境\n一致性：所有开发者使用相同的运行环境\n可移植性：环境定义即代码，易于迁移与复现\n\n\n常见开发环境问题\n\n\n\n问题\nDocker 解决方案\n\n\n\n\n系统差异（Win/macOS/Linux）\n使用统一的容器镜像\n\n\n依赖版本不一致\n使用 Dockerfile 固定依赖\n\n\n环境搭建复杂\n使用 Compose 一键启动\n\n\n本地配置泄露\n使用 .env 文件与挂载隔离\n\n\n\n\n使用 Dockerfile 构建开发环境\n以 Node.js 项目为例：\nFROM node:18\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nCMD [&quot;npm&q"}, {"title": "Docker入门系列 (12) - Docker 微服务架构实践", "date": "2025-10-02", "file": "posts/2025/10/Docker入门系列 (12) - Docker 微服务架构实践.html", "tags": ["Linux", "开发", "Docker"], "content": "微服务架构是一种将应用拆分为多个独立服务的设计模式，每个服务负责单一功能，独立部署与扩展\n本章将介绍如何使用 Docker 构建微服务架构，实现模块化部署、服务隔离与高可用性\n\n什么是微服务架构\n微服务架构的核心理念：\n\n每个服务专注于单一业务功能\n服务之间通过网络通信（如 HTTP、gRPC）\n每个服务可独立部署、扩展与维护\n技术栈可异构（不同服务使用不同语言或框架）\n\n\nDocker 与微服务的天然契合\nDocker 提供了微服务架构所需的基础能力：\n\n每个服务运行在独立容器中，互不干扰\n使用 Compose 或 Swarm 编排多个服务\n快速构建与部署，适合 CI/CD 流程\n支持服务发现与网络隔离\n\n\n微服务架构示例\n假设我们构建一个电商系统，包含以下服务：\n\nfrontend：用户界面\nproduct-service：商品管理\norder-service：订单处理\nuser-service：用户管理\ngateway：统一入口与路由\ndb：数据库服务\n\n\n使用 Docker Compose 构建微服务栈\nversion: '3.8'\nservices:\n gateway:\n "}, {"title": "Docker入门系列 (11) - Docker 与系统服务集成", "date": "2025-10-01", "file": "posts/2025/10/Docker入门系列 (11) - Docker 与系统服务集成.html", "tags": ["Linux", "开发", "Docker"], "content": "在实际部署中，我们常常希望容器能够像系统服务一样运行：自动启动、守护运行、统一管理\n本章将介绍如何将 Docker 容器与系统服务（如 systemd）集成，实现容器的后台运行、开机自启与日志管理\n\n为什么要集成系统服务\n虽然 Docker 本身支持后台运行（-d 参数），但在生产环境中，使用系统服务管理容器具有以下优势：\n\n容器随系统启动自动运行\n容器崩溃后自动重启\n与其他服务统一管理（如 Nginx、PostgreSQL）\n支持日志收集与权限控制\n\n\n使用 systemd 管理容器\n创建 systemd 服务文件\n路径：/etc/systemd/system/myapp.service\n[Unit]\nDescription=My Docker App\nAfter=docker.service\nRequires=docker.service\n\n[Service]\nRestart=always\nExecStart=/usr/bin/docker run --rm -p 8080:80 --name myapp yourname/myapp\nExecStop=/usr/bin/docke"}, {"title": "Docker入门系列 (10) - Docker Registry 镜像仓库管理", "date": "2025-09-30", "file": "posts/2025/09/Docker入门系列 (10) - Docker Registry 镜像仓库管理.html", "tags": ["Linux", "开发", "Docker"], "content": "镜像是容器的基础，而镜像仓库则是容器生态的核心枢纽\n本章将介绍 Docker Registry 的使用方式，包括官方仓库 Docker Hub、自建私有仓库，以及镜像的推送、拉取与版本管理，帮助你构建安全、高效的镜像分发体系\n\n什么是 Docker Registry\nDocker Registry 是用于存储和分发 Docker 镜像的服务。常见类型包括：\n\nDocker Hub：Docker 官方公共仓库，支持公开与私有镜像\nHarbor：企业级私有仓库，支持权限控制与镜像扫描\n自建 Registry：使用官方 registry 镜像快速部署本地仓库\n\n\n镜像的命名规范\n镜像名称格式：\n[仓库地址]/[用户名或组织]/[镜像名]:[标签]\n\n示例：\nnginx:latest\nyourname/myapp:v1.0\nregistry.example.com/backend/api:v2\n\n\n登录与认证\n登录 Docker Hub：\ndocker login\n\n登录私有仓库：\ndocker login registry.example.com\n\n退出登录：\ndocker logout\n\n"}, {"title": "Docker入门系列 (1) - 开篇", "date": "2025-09-21", "file": "posts/2025/09/Docker入门系列 (1) - 开篇.html", "tags": ["Linux", "开发", "Docker"], "content": "在容器技术逐渐成为主流的今天，Docker 与传统虚拟机的差异也成为许多开发者入门时最常遇到的问题\n两者都能实现应用隔离与环境封装，但在架构设计、资源利用、启动效率和安全模型等方面却有本质区别\n本文将从多个维度深入解析 Docker 与虚拟机的核心差异，帮助你理解为什么 Docker 更适合现代化的微服务部署与 DevOps 流程\n\n实现架构上的区别\n\n\n虚拟机架构详解\n\n\n基础设施 (Infrastructure)\n 可以是你的 个人电脑、数据中心的服务器 或者是 云主机\n\n\n主操作系统 (Host OS)\n 运行在基础设施之上，可能是 macOS、Windows 或某个 Linux 发行版\n\n\n虚拟机管理系统 (Hypervisor)\n 用于在主操作系统上运行多个不同的从操作系统 \n\n类型 1：如 HyperKit (macOS)、Hyper-V (Windows)、KVM (Linux) \n\n类型 2：如 VirtualBox、VMWare\n\n\n从操作系统 (Guest OS)\n 每个虚拟机都运行一个完整的操作系统。假设你需要运行 3 个相互隔离的应用，则需要"}, {"title": "DNS测试工具-测一下全世界", "date": "2025-07-16", "file": "posts/2025/07/DNS测试工具-测一下全世界.html", "tags": ["开发", "软件", "网络"], "content": "dnspy - 测试全世界的 DNS 服务器\n数据分析面板预览\n\n数据分析面板，内含示例数据\n测试工具\n在本仓库的 releases 页面中按你的系统架构下载 dnspy-* 文件，比如我的 PC 是 Intel 处理器的 macOS，所以下载 dnspy-darwin-amd64 文件\n然后必须关闭所有代理软件的 Tun 模式、虚拟网卡模式，否则会影响测试结果\n重命名文件为 dnspy（Windows 是 dnspy.exe），然后打开终端，进入到你这个文件所在的目录。执行命令开始测试\nunset http_proxy https_proxy all_proxy HTTP_PROXY HTTPS_PROXY ALL_PROXY\n./dnspy\n\n按提示输入启动测试\n默认使用多线程模式，以加快测试速度。但是默认参数 10 个线程需要至少上下行 1 MB/s 网络和至少 4 核心处理器\n如果网络或处理器不好，会导致测试结果不准确，必须通过-w 参数降低线程数。\n测试完成后会输出到当前目录下形如 dnspy_result_2024-11-07-17-32-13.json 的 JSON 文件"}, {"title": "Byte，bit还傻傻分不清?", "date": "2024-11-13", "file": "posts/2024/11/Byte，bit还傻傻分不清_.html", "tags": ["杂谈", "网络"], "content": "在数字化时代，我们经常听到关于计算机存储单位的术语，例如 Byte 、bit 、 Mbps 和 MB/s 等\n这些单位在计算机科学和信息技术领域起着关键作用，但许多人可能对它们的确切含义和区别感到困惑\n在本文中，我们将深入探讨 Byte 和 bit 的差异，并探讨与之相关的衍生单位，如 Mbps 和 MB/s\nByte 与 bit 的基本概念\nbit（比特）\nbit 是计算机存储单位中的最小单元，它可以表示二进制中的 0 或 1\n一个 bit 就是一个二进制数字\nByte（字节）\nByte 是更大的存储单位，由 8 个 bit 组成\n它通常用来表示一个字符，例如字母、数字或符号\n计算机文件的大小通常以字节为单位表示，例如 1 KB（千字节）等于 1024 字节\nbit 和 Byte 之间的关系\nbit 和 Byte 之间的关系是非常直观的：\n1 Byte = 8 bit\n这是因为 Byte 由 8 个 bit 组成，每个 bit 都代表二进制中的一个位置\n衍伸单位：Mbps和MB/s\nMbps（兆比特每秒）\nMbps 表示兆比特每秒，是网络速度和数据传输速度的常见单位\n兆比特是数据传输"}, {"title": "ArchLinux基础安装", "date": "2024-11-19", "file": "posts/2024/11/ArchLinux基础安装.html", "tags": ["Linux", "杂谈", "开发", "网络"], "content": "本篇参考 Arch Linux 官方安装指南\n禁用 reflector\nreflector 会为你选择速度合适的镜像源\n但其结果并不准确\n同时会清空配置文件中的内容\n对于新人来讲并不适用\n我们首先对其进行禁用\nsystemctl stop reflector.service\n\n再次确保是否为 UEFI 模式\n在一系列的信息刷屏后\n可以看到已经以 root 登陆安装系统了\n此时可以执行的命令\nls /sys/firmware/efi/efivars\n\n若输出了一堆东西，即 efi 变量\n则说明已在 UEFI 模式\n否则请确认你的启动方式是否为 UEFI\n连接网络\n一般来说，你连接的网络几乎均可以通过 DHCP 的方式来进行 IP 地址 和 DNS 的相关设置\n在没有合适网络的情况下，使用 手机的移动热点 也是很方便的选择\n如果你的网络环境需要配置静态 IP 和 DNS\n请自行参考 Arch Wiki\n对于有线连接来说，直接插入网线即可\n对于无线连接，则需进行如下操作进行网络连接\n无线连接使用 iwctl 命令进行，按照如下步骤进行网络连接\niwctl "}, {"title": "Ajax对缓存的处理", "date": "2024-11-15", "file": "posts/2024/11/Ajax对缓存的处理.html", "tags": ["开发", "网络", "前端", "JavaScript"], "content": "缓存\n浏览器的一次请求需要从服务器获得许多css、img、js等相关的文件\n如果每次请求都把相关资源文件加载一次\n对带宽、服务器资源、用户等待时间都有严重的损耗\n浏览器有做优化处理，就是把css、img、js等文件在第一次请求成功后就在本地保留一个缓存备份\n后续的每次请辞u就在本身获得相关的缓存资源文件就可以了\n可以明显地加快用户的访问速度\ncss、img、js等文件可以缓存\n但是动态程序文件例如PHP文件不能进行缓存\n即使缓存我们也不要其缓存效果。\n览器对动态程序文件缓存的处理解决：\n\n给请求的地址设置随机数【推荐】\n给动态程序设置header头信息，禁止浏览器对其缓存\n\n给请求的地址设置随机数\n&lt;!DOCTYPE html&gt; \n&lt;html lang=&quot;en&quot;&gt; \n&lt;head&gt; \n &lt;meta charset=&quot;UTF-8&quot;&gt; \n &lt;title&gt;Ajax对缓存的处理&lt;/title&gt; \n &lt;script type=&quot;t"}, {"title": "80元收的DCN S4600交换机", "date": "2025-12-13", "file": "posts/2025/12/80元收的DCN S4600交换机.html", "tags": ["硬件", "网络设备", "捡漏"], "content": "意外的收获\n今天学校组织了爱心义卖活动，本来只是想去凑个热闹，看看同学们都卖些什么\n逛了一圈，大多是些书籍、文具、小饰品之类的常见物品\n没想到走到一个摊位前，竟然看到了一台 DCN S4600-28P-SI 交换机，标价80元\n这完全出乎我的意料——义卖会上居然会有这种企业级网络设备？\n仔细看了看配置和成色，瞬间心动了\n为什么选择它\nDCN S4600-28P-SI 是神州数码（DCN）推出的一款企业级二层交换机\n主要规格如下：\n- 28个千兆电口（24个普通口 + 4个上联口）\n- 支持 VLAN、STP、链路聚合 等企业级功能\n- 提供 Web 管理和命令行两种管理方式\n- 功耗相对较低，适合家用或小型工作室使用\n性价比分析\n80块钱能买到什么？\n- 一台全新的傻瓜交换机？可能只能买到8口的\n- 一台二手的家用路由器？功能有限，性能一般\n- 但80块能买到28口的企业级交换机，这性价比简直爆表\n虽然是二手设备，但企业级设备的做工和稳定性通常比家用设备好很多\n而且这种设备往往设计寿命更长，用料也更扎实\n使用场景\n我打算用它来做这些事情：\n1. 家庭网络改造：把家里的各种网络设备都接到"}, {"title": "2024年度总结", "date": "2025-01-01", "file": "posts/2025/01/2024年度总结.html", "tags": ["年度总结", "杂谈"], "content": "2024 年，这一年就像做梦一样的度过，还好，我终是梦醒了，也没有睡过头\n这一年里，我完成了许多人生中的“第一次”：第一次交女朋友，第一次构建一台完整的服务器\n我亲眼目睹了我自己的人生，也看到了人生中的美好，体验了万人狂欢的热烈夜晚，也感受到了“风吹草低见牛羊”的诗意与真实\n我的个人站点迎来了第 2 个年头。在努力学习的同时，我不断努力打造个人 IP，将我对编程事业的热爱、科技探索、软件发烧友的多重身份分享给更多人\n在这过程中，我也结识了许多志同道合的朋友，拓宽了自己的视野与圈子\n接下来是我对 2024 年的总结，想与你分享\n学习\n在学习中，我持续保持高质量输出，并不断提升自己的技术影响力\n在项目中，我逐渐担任核心研发角色，并成功迈入开发工程师的行列，迎来了个人专业发展的重要里程碑\n回望今年，也是我学习前后端技术的第三年\n这段旅程充满挑战，但也伴随着成长与喜悦\n站点\n今年，我的站点终于在静态化的阵营中稳稳站住了脚\n经过不断摸索，我逐步完善并打造出了一套专属的部署模式，兼具高效性与性价比，让站点的运维更加从容\n同时，我也在持续努力创作优质文章，不断丰富站点的内容\n今年，看到更多人关注我的"}]; const searchInput = document.getElementById('searchInput'); const searchResults = document.getElementById('searchResults'); const searchInfo = document.getElementById('searchInfo'); function normalizeText(text) { return text.toLowerCase().trim(); } function highlightMatch(text, query) { const index = normalizeText(text).indexOf(normalizeText(query)); if (index === -1) return text; const before = text.substring(0, index); const match = text.substring(index, index + query.length); const after = text.substring(index + query.length); return before + '<mark style="background:var(--link);color:var(--bg);padding:2px 4px;border-radius:2px;">' + match + '</mark>' + after; } function getPreview(text, query, length = 80) { const normalizedText = normalizeText(text); const normalizedQuery = normalizeText(query); const index = normalizedText.indexOf(normalizedQuery); if (index === -1) return ''; const start = Math.max(0, index - 20); const end = Math.min(text.length, start + length); let preview = text.substring(start, end); if (start > 0) preview = '...' + preview; if (end < text.length) preview = preview + '...'; return highlightMatch(preview, query); } function searchPosts(query) { if (!query) { searchResults.innerHTML = ''; searchInfo.textContent = ''; return; } const normalizedQuery = normalizeText(query); const results = postsData.filter(post => { return normalizeText(post.title).includes(normalizedQuery) || normalizeText(post.date).includes(normalizedQuery) || normalizeText(post.content).includes(normalizedQuery); }); if (results.length === 0) { searchInfo.textContent = 'No results found'; searchResults.innerHTML = '<li class="no-results">Try different keywords</li>'; return; } searchInfo.textContent = `Found ${results.length} post${results.length > 1 ? 's' : ''}`; searchResults.innerHTML = results.map(post => { const titleHtml = highlightMatch(post.title, query); const dateHtml = highlightMatch(post.date, query); let preview = ''; if (normalizeText(post.content).includes(normalizedQuery)) { preview = `<div class="search-preview">${getPreview(post.content, query, 100)}</div>`; } return `<li><a href="/${post.file}">${titleHtml}</a> - <span class="post-date">${dateHtml}</span>${preview}</li>`; }).join(''); } let debounceTimer; searchInput.addEventListener('input', (e) => { clearTimeout(debounceTimer); debounceTimer = setTimeout(() => { searchPosts(e.target.value); }, 300); }); const urlParams = new URLSearchParams(window.location.search); const initialQuery = urlParams.get('q'); if (initialQuery) { searchInput.value = initialQuery; searchPosts(initialQuery); } </script><footer><img src="/0unz.png" alt="0u logo" class="footer-logo"></footer></body></html>